# v1.1 Design — Channel Versioning + `versions_seen`-Style Triggers (Design Only)

This document explores a v1.1 feature track for Hive that adds **channel versioning** and **deterministic triggers** inspired by LangGraph’s `versions_seen`, without changing v1 runtime semantics.

## Goals
- Provide a deterministic, checkpointable way to answer: “Has channel X changed since node N last ran?”
- Enable optional node triggers (skip scheduling) without introducing non-determinism.
- Preserve v1 invariants: supersteps, commit order, join semantics, interrupt/resume behavior, and event determinism.

## Non-goals
- Implementing triggers in v1.1 (this is design only).
- Allowing nodes to “subscribe” implicitly by dynamic read-tracking (too subtle for determinism).

---

## 1) What is a “channel version”?

Two plausible representations:

### Option A — Counter version (recommended)
- Each channel has a monotonically increasing `UInt64` **version counter**.
- The version increments deterministically **once per committed step** for each channel that had at least one committed write in that step (even if the reducer yields an equal value).

Pros:
- Cheap to update and store.
- Deterministic without requiring equality or codec support.

Cons:
- Can increment even when “value didn’t change” (by semantic equality), but this is usually acceptable for triggers.

### Option B — Hash version (optional supplement)
- Each channel’s version is the **hash** of its post-commit canonical bytes.
- Requires stable canonical encoding for the channel value.

Pros:
- Represents “value identity” rather than “write activity”.

Cons:
- Requires codec or canonical encoder for every triggerable channel.
- More CPU and more failure modes (encoding failures).

### Proposed direction
Use **Option A** as the primary persisted versioning mechanism. Hash-based versions can be explored later as an opt-in for channels with codecs.

---

## 2) What is persisted in checkpoints?

### Persisted fields (new in checkpoint format vNext)
1. `channelVersionsByChannelID: [String: UInt64]`
   - For global channels only (task-local versions are less useful for global triggers and increase size).
   - Deterministic key ordering: lexicographic UTF-8 by channel ID.

2. `versionsSeenByNodeID: [String: [String: UInt64]]`
   - For each node with trigger configuration, store the last seen version for each relevant channel.
   - Stored only for triggerable channels (avoid “all channels for all nodes” explosion).

3. `updatedChannelsLastCommit: [String]` (optional convenience)
   - The set of channels that were written in the last committed step.
   - Can be derived from commit data, but persisting can simplify debugging and future features.

### Why persist `versionsSeen`?
Triggers must remain correct across resume. If a node was skipped due to “no changes”, it must remain skippable after resume unless new writes occur.

---

## 3) Trigger rules (when nodes run) while keeping determinism

### Key design requirement
Hive nodes can read any channel via `HiveStoreView`. If triggers depend on “what a node read last time”, behavior becomes sensitive to code paths and can subtly break determinism.

### Proposed trigger declaration model (compile-time)
Add optional, explicit trigger configuration per node:

- `runWhen: .always` (default, v1 semantics)
- `runWhen: .anyOf(channels: [HiveChannelID])`
- `runWhen: .allOf(channels: [HiveChannelID])` (rare but useful)

And optionally:
- `initialRun: .always` (first run of a thread)
- `initialRun: .onlyIfInputWritesTouched(channels: …)` (advanced)

### Scheduling rule
At commit boundary (superstep end), for each candidate task seed:
1. Resolve the node’s trigger config.
2. Look up the current channel versions and the node’s `versionsSeen`.
3. If trigger predicate is false → do not schedule the task seed.
4. If predicate is true → schedule normally, preserving all existing ordering rules.

### Updating `versionsSeen`
Update `versionsSeen` deterministically:
- When a node task **starts** (or equivalently when it is scheduled), snapshot the relevant channel versions into `versionsSeenByNodeID[nodeID]`.
- Prefer “on task start” to avoid divergence between “scheduled but never executed” (failures/cancellation) and “executed” semantics. This must be designed carefully if retries exist.

### Determinism considerations
- Trigger evaluation must use only deterministic inputs: committed writes, deterministic reducer results (already required), and deterministic order of channel version updates.
- If a step fails and does not commit, channel versions MUST NOT advance.

---

## 4) Checkpoint format versioning / migration strategy

### Add a checkpoint format version tag
Introduce a top-level `checkpointFormatVersion` field (e.g., `"HCP2"`).

### Loading older checkpoints
When a checkpoint lacks versioning fields:
- Initialize `channelVersionsByChannelID` to all zeros (or empty map treated as zero).
- Initialize `versionsSeenByNodeID` to empty.

### Migration behavior
This migration MUST be deterministic:
- The derived default versions are purely structural.
- Triggers should treat “no versions seen” as “changed” (i.e., nodes run at least once).

---

## 5) Test plan (prevent subtle regressions)

### Golden and unit-level tests
- Version increments:
  - A committed step with writes to channel `a` increments `a` exactly once regardless of write count.
  - Steps with no committed writes do not change versions.
- Determinism:
  - Repeated runs with identical inputs produce identical `channelVersionsByChannelID` and identical scheduling decisions.
- Resume parity:
  - A run that checkpoints and resumes must produce the same triggers/scheduling outcomes as uninterrupted run.

### Property-style tests (optional but high value)
- Randomized graphs where writes happen in multiple tasks:
  - Ensure version maps are stable and independent of task completion timing (only commit order matters).

### Migration tests
- Loading an older checkpoint without version fields:
  - Triggerable nodes run at least once deterministically.
  - After the first commit, versionsSeen is populated deterministically.

---

## Open questions
- Should versions be tracked for task-local channels (probably not for v1.1)?
- Is “update on schedule” or “update on task start” the right point given retries/cancellation?
- Do we want an opt-in “hash version” for channels with codecs to detect semantic equality?

