# v1.1 Design — Generalized Barrier / Topic Channels (Design Only)

This document explores a v1.1 feature track for introducing **generalized barrier/topic channels**. Hive v1 already supports joins via join edges; this track considers whether exposing “barriers as channels” is useful and how to keep it deterministic and hard to misuse.

## Goals
- Provide a Swift-typed, ergonomic API for “wait until a condition across producers is satisfied”.
- Preserve determinism and checkpointability.
- Avoid leaking runtime internals into user code.

## Non-goals
- Implementing a full reactive runtime.
- Replacing v1 join edges (join edges remain the primary join mechanism).

---

## 1) User-facing API shape (Swift-typed, misuse-resistant)

### Design principles
- Users should not manually concatenate IDs or encode tokens.
- The API should make invalid states unrepresentable where possible.

### Proposed API directions (sketch)

#### Barrier channel
A barrier represents “seen” tokens keyed by barrier + producer.

```swift
public struct HiveBarrierKey: Hashable, Sendable, Codable { /* opaque */ }
public struct HiveBarrierToken: Hashable, Sendable, Codable { /* opaque */ }

public enum HiveBarrierUpdate: Sendable, Codable {
    case markSeen(barrier: HiveBarrierKey, producer: HiveNodeID, token: HiveBarrierToken)
    case consume(barrier: HiveBarrierKey)
}
```

The runtime (or a helper) can provide deterministic reducers that:
- accumulate `markSeen` updates into a set/dictionary
- apply `consume` deterministically at commit time

#### Topic channel
A topic represents append-only or reduced streams of values keyed by topic.

```swift
public struct HiveTopicKey: Hashable, Sendable, Codable { /* opaque */ }
public enum HiveTopicUpdate<Value: Sendable & Codable>: Sendable, Codable {
    case publish(topic: HiveTopicKey, value: Value)
    case clear(topic: HiveTopicKey)
}
```

---

## 2) State representation and checkpointing implications

### Barrier representation
Persisted state could be:
- `barrierSeenByBarrierID: [BarrierKey: Set<NodeID>]`
- or `barrierSeenTokensByBarrierID: [BarrierKey: [NodeID: Token]]` (if tokens matter)

Checkpoint implications:
- Must be fully Codable and deterministically ordered (sorted keys, stable encoding).
- If barriers are long-lived, state can grow. Define expectations and optional compaction policies.

### Topic representation
Persisted state could be:
- append-only list (bounded) per topic
- or reduced aggregate per topic (preferred for determinism + storage)

Checkpoint implications:
- append-only topics must define deterministic eviction policy when bounded.

---

## 3) Determinism and backpressure semantics

### Determinism rules
- All merges happen at commit time, using existing deterministic reducer rules.
- “Consume” semantics must be deterministic:
  - consume applies only if the barrier is “available” per a deterministic predicate
  - if available, consume clears the relevant stored state deterministically

### Backpressure
If topics represent high-frequency streams (e.g., tokens), backpressure must be explicit:
- bounded buffers with deterministic drop/coalesce policy
- or disallow “streaming topics” in checkpointed channels (leave to event stream)

---

## 4) Minimal viable subset vs full generality

### Minimal viable subset (recommended first)
- Provide typed reducers and data structures to represent barriers/topics in channels.
- Provide helper utilities (pure functions) to evaluate:
  - “is barrier available?” given state + expected producers
  - “consume barrier” deterministically
- Keep joins as edges for core scheduling; barrier channels are for user-level state modeling and diagnostics.

### Full generality (defer)
- Arbitrary topic subscriptions triggering node scheduling.
- Barrier channels that directly participate in scheduling without edges (requires trigger system; see v1.1 triggers doc).

---

## Test plan (when implemented)
- Deterministic reducer behavior under multiple writes.
- Checkpoint/resume parity for barrier/topic state.
- Growth and compaction invariants (bounded topics).
- Interop tests with join edges (barrier channel used only for state/diagnostics does not change join semantics).

